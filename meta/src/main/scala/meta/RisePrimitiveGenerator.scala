package meta

import fastparse.{Parsed, parse}
import meta.NatParser.NatAST
import meta.TypeParser.TypeAST

object RisePrimitiveGenerator {
  def main(args: Array[String]): Unit = {
    val sourceDir = args.head
    val rise = os.Path(sourceDir) / "rise"
    os.walk.stream(rise).filter(_.ext == "rise").foreach(path => {

      val definition = os.read(path)
      parse(definition, TypeParser.PrimitiveDeclarations(_)) match {
        case failure: Parsed.Failure =>
          println(s"Failed to parse `${failure.extra.input}'")
          println(s"  $failure")
        case Parsed.Success(seq, _) =>
          seq.foreach {
            case (name, typeSignature) =>
              val outputPath = (path / os.up) / s"${name}.scala"
              println(s"Generate $outputPath")
              import scala.meta._

              val packageName = path.relativeTo(rise).segments.dropRight(1).foldLeft[Term.Ref](Term.Name("rise")) {
                case (t, name) => Term.Select(t, Term.Name(name))
              }
              val code = s"""// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! //
                            |// This file is automatically generated and should not be changed manually //
                            |// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! //
                            |${q"""
package $packageName {

import rise.core.DSL._
import rise.core.DSL.Type._
import rise.core._
import rise.core.types._
import arithexpr.arithmetic._

${generateCaseClassAndObject(name, typeSignature)}

}""".toString()}
                            |""".stripMargin

              os.write.over(outputPath, code)
          }
      }
    })
  }

  def generateCaseClassAndObject(name: String, typeSignature: TypeAST): scala.meta.Defn.Object = {
    import scala.meta._
    val generated = q"""
      object ${Term.Name{name}}  extends Builder {
        private final case class Primitive()(override val t: Type = TypePlaceholder)
          extends rise.core.Primitive {
        override val name: String = ${Lit.String(name)}
        override def setType(ty: Type): Primitive =
          Primitive()(ty)
        override def typeScheme: Type =
          ${generateTypeScheme(typeSignature, Map.empty)}

        override def equals(obj: Any): Boolean = obj match {
          case p: Primitive => p.t =~= t
          case _ => false
        }
      }

        override def primitive: rise.core.Primitive = Primitive()()
        override def apply: ToBeTyped[rise.core.Primitive] =
          toBeTyped(Primitive()())
        override def unapply(arg: Expr): Boolean = arg match {
          case _: Primitive => true
          case _ => false
        }
      }"""
    generated
  }

  def generateTypeScheme(typeAST: TypeAST, env: Map[TypeAST.TypeIdentifier, String]): scala.meta.Term = {
    import scala.meta._
    typeAST match {
      case id@TypeAST.TypeIdentifier(name) =>
        assert(env.contains(id), s"$id is not in $env")
        Term.Name(name)
      case TypeAST.FunType(inT, outT) =>
        q"(${generateTypeScheme(inT, env)}) ->: (${generateTypeScheme(outT, env)})"
      case TypeAST.DepFunType(id, kind, t) =>
        q"expl((${Term.Name(id.name)}: ${Type.Name(kindName(kind))}) => ${generateTypeScheme(t, env.updated(id, kind))})"
      case TypeAST.ImplicitDepFunType(id, kind, t) =>
        q"impl((${Term.Name(id.name)}: ${Type.Name(kindName(kind))}) => ${generateTypeScheme(t, env.updated(id, kind))})"
      case TypeAST.ScalarType(t) =>
        t.parse[Term].get
      case TypeAST.NatType =>
        q"rise.core.types.NatType"
      case TypeAST.VectorType(size, elemType) =>
        q"rise.core.types.VectorType(${generateNat(size, env)}, ${generateTypeScheme(elemType, env)})"
      case TypeAST.IndexType(size) =>
        q"rise.core.types.IndexType(${generateNat(size, env)})"
      case TypeAST.PairType(lhs, rhs) =>
        q"rise.core.types.PairType(${generateTypeScheme(lhs, env)}, ${generateTypeScheme(rhs, env)})"
      case TypeAST.DepPairType(id, kind, t) => kind match {
        case "nat" =>
          q"Nat `**` ((${Term.Name(id.name)}: Nat) => ${generateTypeScheme(t, env.updated(id, kind))})"
        case _ => ???
      }
      case TypeAST.NatToDataApply(f, n) =>
        q"rise.core.types.NatToDataApply(${generateTypeScheme(f, env)}, ${generateNat(n, env)})"
      case TypeAST.NatToDataLambda(id, t) =>
        q"n2dtFun((${Term.Name(id.name)}: NatIdentifier) => ${generateTypeScheme(t, env.updated(id, "nat"))})"
      case TypeAST.ArrayType(size, elemType) =>
        q"rise.core.types.ArrayType(${generateNat(size, env)}, ${generateTypeScheme(elemType, env)})"
      case TypeAST.DepArrayType(size, fdt) =>
        q"rise.core.types.DepArrayType(${generateNat(size, env)}, ${generateTypeScheme(fdt, env)})"
    }
  }

  def kindName(kind: String): String = kind match {
    case "nat" => "Nat"
    case "data" => "DataType"
    case "nat2nat" => "NatToNat"
    case "nat2data" => "NatToData"
  }

  def generateNat(n: NatAST, env: Map[TypeAST.TypeIdentifier, String]): scala.meta.Term = {
    import scala.meta._
    n match {
      case NatAST.Identifier(id) =>
        assert(env.contains(id), s"$id is not in $env")
        Term.Name(id.name)
      case NatAST.Number(n) =>
        n.parse[Term].get
      case NatAST.BinaryOp(lhs, op, rhs) =>
        q"${generateNat(lhs, env)} ${Term.Name(op)} ${generateNat(rhs, env)}"
      case NatAST.TernaryOp(cond, thenN, elseN) =>
        val operator: Term = cond.op match {
          case "<" => q"Operator.<"
          case ">" => q"Operator.>"
        }
        q"""
           IfThenElse(
              arithPredicate(${generateNat(cond.lhs, env)}, ${generateNat(cond.rhs, env)}, $operator),
              ${generateNat(thenN, env)},
              ${generateNat(elseN, env)})
         """
      case NatAST.Nat2NatApply(f, n) =>
        q"${generateTypeScheme(f, env)}(${generateNat(n, env)})"
      case NatAST.Sum(id, from, upTo, body) =>
        q"""BigSum(
              from = ${generateNat(from, env)},
              upTo = ${generateNat(upTo, env)},
              (${Term.Name(id.id.name)}: Nat) => ${generateNat(body, env.updated(id.id, "nat"))})
         """
    }
  }
}
