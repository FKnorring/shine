package meta

import fastparse.{Parsed, parse}
import meta.NatParser.NatAST
import meta.RiseTypeParser.RISETypeAST
import meta.RiseTypeParser.RISETypeAST.{FragmentAST, MatrixLayoutAST}

object RisePrimitiveGenerator {
  def main(args: Array[String]): Unit = {
    val sourceDir = args.head
    val rise = os.Path(sourceDir) / "rise"
    os.walk.stream(rise).filter(_.ext == "rise").foreach(path => {

      val definition = os.read(path)
      parse(definition, RiseTypeParser.PrimitiveDeclarations(_)) match {
        case failure: Parsed.Failure =>
          println(s"Failed to parse `${failure.extra.input}'")
          println(s"  $failure")
        case Parsed.Success(seq, _) =>
          seq.foreach {
            case (name, args, typeSignature) if RiseTypeParser.isWellKindedType(typeSignature) =>
              val outputPath = (path / os.up) / s"$name.scala"
              println(s"Generate $outputPath")

              val generatedDef = args match {
                case None =>
                  generateObject(name, typeSignature)
                case Some((start, end)) =>
                  generateCaseClass(name, definition.substring(start, end), typeSignature)
              }

              import scala.meta._
              val packageName = path.relativeTo(rise).segments.dropRight(1).foldLeft[Term.Ref](Term.Name("rise")) {
                case (t, name) => Term.Select(t, Term.Name(name))
              }
              val code = s"""// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! //
                            |// This file is automatically generated and should not be changed manually //
                            |// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! //
                            |${q"""
package $packageName {

import rise.core.DSL._
import rise.core.DSL.Type._
import rise.core._
import rise.core.types._
import arithexpr.arithmetic._

..${generatedDef.stats}

}""".toString()}
                            |""".stripMargin

              os.write.over(outputPath, code)
            case (name, _, typeSignature) =>
              println(s"Could not generate code for `$name' as type signature `$typeSignature' is not well kinded.")
          }
      }
    })
  }

  def generateObject(name: String, typeSignature: RISETypeAST): scala.meta.Term.Block = {
    import scala.meta._
    val generated = q"""{
      object ${Term.Name{name}} extends Builder {
        private final case class Primitive()(override val t: Type = TypePlaceholder)
          extends rise.core.Primitive
        {
          override val name: String = ${Lit.String(name)}
          override def setType(ty: Type): Primitive = Primitive()(ty)
          override def typeScheme: Type = ${generateTypeScheme(typeSignature, Map.empty)}

          override def equals(obj: Any): Boolean = obj match {
            case p: Primitive => p.t =~~= t
            case _ => false
          }
        }

        override def toString: String = ${Lit.String(name)}
        override def primitive: rise.core.Primitive = Primitive()()
        override def apply: ToBeTyped[rise.core.Primitive] = toBeTyped(Primitive()())
        override def unapply(arg: Expr): Boolean = arg match {
          case _: Primitive => true
          case _ => false
        }
      }
      }"""
    generated
  }

  def generateCaseClass(name: String, paramsString: String, typeSignature: RISETypeAST): scala.meta.Term.Block = {
    import scala.meta._

    val params = paramsString.split(",").map(param => {
      val parts = param.split(":").map(_.trim)
      param"${Term.Name(parts(0))}: ${Type.Name(parts(1))}"
    } ).toList
    val args: List[Term.Name] = params.map(p => Term.Name(p.name.value))
    val types: List[Type] = params.map(p => p.decltpe.get)

    val generated =
      q"""
      final case class ${Type.Name(name)}(..$params) extends Builder {
        override def toString: String = ${Lit.String(name)}
        override def primitive: rise.core.Primitive = ${Term.Name(name)}.Primitive(..$args)()
        override def apply: ToBeTyped[rise.core.Primitive] = toBeTyped(${Term.Name(name)}.Primitive(..$args)())

        override def unapply(arg: Expr): Boolean = arg match {
          case _: Primitive => true
          case _ => false
        }
      }

      object ${Term.Name(name)} {
        private final case class Primitive(..$params)(override val t: Type = TypePlaceholder)
          extends rise.core.Primitive
        {
          override val name: String = ${Lit.String(name)}
          override def setType(ty: Type): Primitive = Primitive(..$args)(ty)
          override def typeScheme: Type = ${generateTypeScheme(typeSignature, Map.empty)}

          override def equals(obj: Any): Boolean = obj match {
            case p: Primitive =>
              ${generateComparisonChain(args)} && p.t =~~= t
            case _ => false
          }
        }

        def unapply(arg: rise.core.Expr): Option[..$types] = arg match {
          case p: Primitive =>
            Some(..${generateMemberAccesses(args)})
          case _ => None
        }
      }
       """
    generated
  }

  def generateTypeScheme(typeAST: RISETypeAST, env: Map[String, String]): scala.meta.Term = {
    import scala.meta._
    typeAST match {
      case RISETypeAST.Identifier(name) =>
        assert(env.contains(name), s"$name is not in $env")
        Term.Name(name)
      case RISETypeAST.FunType(inT, outT) =>
        q"(${generateTypeScheme(inT, env)}) ->: (${generateTypeScheme(outT, env)})"
      case RISETypeAST.DepFunType(id, kind, t) =>
        q"expl((${Term.Name(id.name)}: ${Type.Name(kindName(kind))}) => ${generateTypeScheme(t, env.updated(id.name, kind))})"
      case RISETypeAST.ImplicitDepFunType(id, kind, t) =>
        q"impl((${Term.Name(id.name)}: ${Type.Name(kindName(kind))}) => ${generateTypeScheme(t, env.updated(id.name, kind))})"
      case RISETypeAST.ScalarType(t) =>
        t.parse[Term].get
      case RISETypeAST.NatType =>
        q"rise.core.types.NatType"
      case RISETypeAST.VectorType(size, elemType) =>
        q"rise.core.types.VectorType(${generateNat(size, env)}, ${generateTypeScheme(elemType, env)})"
      case RISETypeAST.IndexType(size) =>
        q"rise.core.types.IndexType(${generateNat(size, env)})"
      case RISETypeAST.PairType(lhs, rhs) =>
        q"rise.core.types.PairType(${generateTypeScheme(lhs, env)}, ${generateTypeScheme(rhs, env)})"
      case RISETypeAST.DepPairType(id, kind, t) => kind match {
        case "nat" =>
          q"Nat `**` ((${Term.Name(id.name)}: Nat) => ${generateTypeScheme(t, env.updated(id.name, kind))})"
        case _ => ???
      }
      case RISETypeAST.NatToDataApply(f, n) =>
        q"rise.core.types.NatToDataApply(${generateTypeScheme(f, env)}, ${generateNat(n, env)})"
      case RISETypeAST.NatToDataLambda(id, t) =>
        q"n2dtFun((${Term.Name(id.name)}: NatIdentifier) => ${generateTypeScheme(t, env.updated(id.name, "nat"))})"
      case RISETypeAST.ArrayType(size, elemType) =>
        q"rise.core.types.ArrayType(${generateNat(size, env)}, ${generateTypeScheme(elemType, env)})"
      case RISETypeAST.DepArrayType(size, fdt) =>
        q"rise.core.types.DepArrayType(${generateNat(size, env)}, ${generateTypeScheme(fdt, env)})"
      case RISETypeAST.FragmentType(n, m, k, elemType, fKind, mLayout) =>
        q"rise.core.types.FragmentType(${generateNat(n, env)}, ${generateNat(m, env)}, ${generateNat(k, env)}, ${generateTypeScheme(elemType, env)}, ${generateFragment(fKind, env)}, ${generateMatrixLayout(mLayout, env)})"
    }
  }

  def kindName(kind: String): String = kind match {
    case "nat" => "Nat"
    case "data" => "DataType"
    case "nat2nat" => "NatToNat"
    case "nat2data" => "NatToData"
    case "address" => "AddressSpace"
    case "fragment" => "FragmentKind"
    case "matrixLayout" => "MatrixLayout"
  }

  def generateNat(n: NatAST, env: Map[String, String]): scala.meta.Term = {
    import scala.meta._
    n match {
      case NatAST.Identifier(id) =>
        assert(env.contains(id), s"$id is not in $env")
        Term.Name(id)
      case NatAST.Number(n) =>
        n.parse[Term].get
      case NatAST.BinaryOp(lhs, "^", rhs) =>
        q"${generateNat(lhs, env)}.pow(${generateNat(rhs, env)})"
      case NatAST.BinaryOp(lhs, op, rhs) =>
        q"${generateNat(lhs, env)} ${Term.Name(op)} ${generateNat(rhs, env)}"
      case NatAST.TernaryOp(cond, thenN, elseN) =>
        val operator: Term = cond.op match {
          case "<" => q"Operator.<"
          case ">" => q"Operator.>"
        }
        q"""
           IfThenElse(
              arithPredicate(${generateNat(cond.lhs, env)}, ${generateNat(cond.rhs, env)}, $operator),
              ${generateNat(thenN, env)},
              ${generateNat(elseN, env)})
         """
      case NatAST.Nat2NatApply(f, n) =>
        q"${generateTypeScheme(f, env)}(${generateNat(n, env)})"
      case NatAST.Sum(id, from, upTo, body) =>
        q"""BigSum(
              from = ${generateNat(from, env)},
              upTo = ${generateNat(upTo, env)},
              (${Term.Name(id.name)}: Nat) => ${generateNat(body, env.updated(id.name, "nat"))})
         """
    }
  }

  def generateFragment(fragmentAST: FragmentAST, env: Map[String, String]): scala.meta.Term = {
    import scala.meta._
    fragmentAST match {
      case FragmentAST.Identifier(name) =>
        assert(env.contains(name), s"$name is not in $env")
        Term.Name(name)
      case FragmentAST.ACC =>
        q"rise.core.types.FragmentKind.Acuumulator"
      case FragmentAST.A =>
        q"rise.core.types.FragmentKind.AMatrix"
      case FragmentAST.B =>
        q"rise.core.types.FragmentKind.BMatrix"
    }
  }

  def generateMatrixLayout(matrixLayoutAST: MatrixLayoutAST, env: Map[String, String]): scala.meta.Term = {
    import scala.meta._
    matrixLayoutAST match {
      case MatrixLayoutAST.Identifier(name) =>
        assert(env.contains(name), s"$name is not in $env")
        Term.Name(name)
      case MatrixLayoutAST.ROW_MAJOR =>
        q"rise.core.types.MatrixLayout.Row_Major"
      case MatrixLayoutAST.COL_MAJOR =>
        q"rise.core.types.MatrixLayout.Col_Major"
    }
  }

  def generateComparisonChain(args: List[scala.meta.Term.Name]): scala.meta.Term = {
    import scala.meta._
    args match {
      case List() => q"true"
      case head :: tail =>
        q"(p.$head == $head) && ${generateComparisonChain(tail)}"
    }
  }

  def generateMemberAccesses(args: List[scala.meta.Term.Name]): List[scala.meta.Term] = {
    import scala.meta._
    args match {
      case List() => List(q"()")
      case List(arg) => List(q"p.$arg")
      case head :: tail =>
        q"p.$head" :: generateMemberAccesses(tail)
    }
  }
}
