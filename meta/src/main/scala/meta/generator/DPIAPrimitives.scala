package meta.generator

import fastparse.{Parsed, parse}
import meta.parser._

object DPIAPrimitives {
  def main(args: Array[String]): Unit = {
    val sourceDir = args.head
    val shinePath = os.Path(sourceDir) / "shine"
    os.walk.stream(shinePath).filter(_.ext == "dpia").foreach(path => {

      import DPIA.Decl.AST._

      val definition = os.read(path)
      parse(definition, DPIA.Decl.PrimitiveDeclarations(_)) match {
        case failure: Parsed.Failure =>
          println(s"Failed to parse `${failure.extra.input}'")
          println(s"  $failure")
        case Parsed.Success(seq, _) =>
          seq.foreach {
            case PrimitiveDeclaration(Identifier(originalName), scalaParams, params, returnType)
              if DPIA.isWellKindedDefinition(toParamList(definition, scalaParams), params, returnType) =>
              val name = originalName.capitalize

              val outputPath = (path / os.up) / s"$name.scala"
              println(s"Generate $outputPath")

              import scala.meta._
              val packageName = path.relativeTo(shinePath).segments.dropRight(1).foldLeft[Term.Ref](Term.Name("shine")) {
                case (t, name) => Term.Select(t, Term.Name(name))
              }

              val code = s"""// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! //
                            |// This file is automatically generated and should not be changed manually //
                            |// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! //
                            |${q"""
package $packageName {

import arithexpr.arithmetic._
import shine.DPIA.Phrases._
import shine.DPIA.Types.DataType._
import shine.DPIA.Types._
import shine.DPIA._

${generateCaseClass(Type.Name(name), toParamList(definition, scalaParams), params, returnType)}

}""".toString()}
                            |""".stripMargin

              os.write.over(outputPath, code)
            case PrimitiveDeclaration(Identifier(name), _, params, returnType) =>
              println(s"Could not generate code for `$name' as parameters `$params' and/or `$returnType' are not well kinded.")
          }
      }
    })
  }

  def generateCaseClass(name: scala.meta.Type.Name,
                        scalaParams: Option[List[scala.meta.Term.Param]],
                        params: Seq[DPIA.Decl.AST.Param],
                        returnType: DPIA.Type.AST): scala.meta.Defn.Class = {
    import scala.meta._
    import meta.parser.DPIA.Type.AST
    val (scalaReturnType, superClass) = returnType match {
      case AST.ExpType(_, _) => (t"ExpType", init"ExpPrimitive")
      case AST.AccType(_) => (t"AccType", init"AccPrimitive")
      case AST.CommType => (t"CommType", init"CommandPrimitive")
      case _ => throw new Exception(s"Expected `exp', `acc' or `comm' as return type for ${name.value}")
    }
    val generatedParams = generateParams(scalaParams, params)
    q"""
      final case class $name(...$generatedParams) extends $superClass {
        {
          ..${generateTypeChecks(params).stats}
        }

        ..${if (scalaReturnType != t"CommType") {
            List(q"override val t: $scalaReturnType = ${generateTerm(returnType)}")
          } else List() }

        ${generateVisitAndRebuild(name, generatedParams)}

        ..${if (scalaParams.nonEmpty && generatedParams.last.size > 1) {
              List(generateUnwrap(generatedParams.last))
            } else List() }
      }
    """
  }

  def toParamList(definition: String, scalaParams: Option[(Int, Int)]): Option[List[scala.meta.Term.Param]] = {
    import scala.meta._
    scalaParams.map { case (start, end) =>
      s"def foo(${definition.substring(start, end)})".parse[Stat].get match {
        case declDef: Decl.Def => declDef.paramss.head
      }
    }
  }

  def generateParams(scalaParams: Option[List[scala.meta.Term.Param]],
                     params: Seq[DPIA.Decl.AST.Param]): List[List[scala.meta.Term.Param]] = {
    import scala.meta._

    scalaParams match {
      case Some(scalaParamList) =>
        List(scalaParamList) ++ List(params.map(generateParam).toList)
      case None =>
        List(params.map(generateParam).toList)
    }
  }

  def generateParam(param: DPIA.Decl.AST.Param): scala.meta.Term.Param = {
    import scala.meta._
    import _root_.meta.parser.DPIA.Kind
    param"val ${Term.Name(param.id.name)}: ${
      param.ty match {
        case Left(kindAST) => generateType(kindAST)
        case Right(meta.parser.DPIA.Type.AST.VariadicType(_, typeAST)) =>
          t"Seq[Phrase[${generatePhraseType(typeAST)}]]"
        case Right(typeAST) => t"Phrase[${generatePhraseType(typeAST)}]"
      }
    }"
  }

  def generateTypeChecks(params: Seq[DPIA.Decl.AST.Param]): scala.meta.Term.Block = {
    import scala.meta._
    q"""{
      ..${params.
            filter(param => param.ty.isRight). // only check types for parameters with phrase types
            map(param =>
              param.ty match {
                case Right(typeAST@DPIA.Type.AST.DepFunType(id, _, _)) =>
                  q"""${Term.Name(param.id.name)} :: {
                     ${Defn.Val(
                        mods = Nil,
                        pats = List(Pat.Var(name = Term.Name(id.name))),
                        decltpe = None,
                        rhs = q"${Term.Name(param.id.name)}.t.x"
                      )}
                     ${generateTerm(typeAST)}
                   }"""
                case Right(DPIA.Type.AST.VariadicType(n, typeAST)) =>
                  getUnrolledIds(typeAST) match {
                    case Some(unrolledIds) =>
                      val zips = unrolledIds.foldLeft[Term](Term.Name(param.id.name)) {
                        case (term, id) => q"$term.zip(${Term.Name(id.name)})"
                      }
                      val p = Term.Name(param.id.name)
                      val pattern = unrolledIds.foldRight[Pat](Pat.Var(p)) {
                        case (id, pattern) => p"($pattern, ${Pat.Var(Term.Name(id.name))})"
                      }
                      q"""$zips.foreach {
                        case ($pattern) => $p :: ${generateTerm(typeAST)}
                      }"""
                    case None =>
                      q"${Term.Name(param.id.name)}.foreach(_ :: ${generateTerm(typeAST)})"
                  }
                case Right(typeAST) =>
                  q"${Term.Name(param.id.name)} :: ${generateTerm(typeAST)}"
                case Left(_) => throw new Exception("Generation of type checks not necessary for kinds")
              }
            ).toList}
    }"""
  }

  def getUnrolledIds(typeAST: DPIA.Type.AST): Option[Seq[rise.Type.AST.UnrolledIdentifier]] = {
    import DPIA.Type.AST
    typeAST match {
      case AST.ExpType(dataType, _) =>
        getUnrolledIds(dataType)
      case AST.AccType(dataType) =>
        getUnrolledIds(dataType)
      case AST.CommType => None
      case AST.PairType(lhs, rhs) =>
        for {
          ids1 <- getUnrolledIds(lhs)
          ids2 <- getUnrolledIds(rhs)
        } yield ids1 concat ids2
      case AST.FunType(inT, outT) =>
        for {
          ids1 <- getUnrolledIds(inT)
          ids2 <- getUnrolledIds(outT)
        } yield ids1 concat ids2
      case AST.DepFunType(_, _, t) =>
        getUnrolledIds(t)
      case AST.Identifier(_) => None
      case AST.VariadicType(n, ty) => throw new Exception("This function should not be called on a variadic type")
    }
  }

  def getUnrolledIds(typeAST: rise.Type.AST): Option[Seq[rise.Type.AST.UnrolledIdentifier]] = {
    import rise.Type.AST
    typeAST match {
      case AST.Identifier(_) => None
      case id@AST.UnrolledIdentifier(_) => Some(Seq(id))
      case AST.FunType(inT, outT) =>
        for {
          ids1 <- getUnrolledIds(inT)
          ids2 <- getUnrolledIds(outT)
        } yield ids1 concat ids2
      case AST.DepFunType(_, _, t) =>
        getUnrolledIds(t)
      case AST.ImplicitDepFunType(_, _, t) =>
        getUnrolledIds(t)
      case AST.VariadicFunType(_, _, _) => throw new Exception("This function should not be called on a variadic type")
      case AST.VariadicDepFunType(_, _, _, _) => throw new Exception("This function should not be called on a variadic type")
      case AST.ScalarType(_) => None
      case AST.NatType => None
      case AST.OpaqueType(_) => None
      case AST.VectorType(_, elemType) => getUnrolledIds(elemType)
      case AST.IndexType(_) => None
      case AST.PairType(lhs, rhs) =>
        for {
          ids1 <- getUnrolledIds(lhs)
          ids2 <- getUnrolledIds(rhs)
        } yield ids1 concat ids2
      case AST.DepPairType(_, _, t) => getUnrolledIds(t)
      case AST.NatToDataApply(_, _) => None
      case AST.NatToDataLambda(_, t) => getUnrolledIds(t)
      case AST.ArrayType(_, elemType) => getUnrolledIds(elemType)
      case AST.DepArrayType(_, _) => None
      case AST.FragmentType(_, _, _, dt, _, _) => getUnrolledIds(dt)
      case AST.ManagedBufferType(t) => getUnrolledIds(t)
    }
  }

  def generatePhraseType(typeAST: DPIA.Type.AST): scala.meta.Type = {
    import scala.meta._
    import meta.parser.DPIA.Type.AST
    typeAST match {
      case AST.ExpType(_, _) => t"ExpType"
      case AST.AccType(_) => t"AccType"
      case AST.CommType => t"CommType"
      case AST.PairType(lhs, rhs) => t"PhrasePairType[${generatePhraseType(lhs)}, ${generatePhraseType(rhs)}]"
      case AST.FunType(inT, outT) => t"FunType[${generatePhraseType(inT)}, ${generatePhraseType(outT)}]"
      case AST.DepFunType(id, kind, t) => t"DepFunType[${generateKindType(kind)}, ${generatePhraseType(t)}]"
      case AST.Identifier(name) => Type.Name(name)
      case AST.VariadicType(_, _) => throw new Exception("Can not generate Phrase Type for Variadic Type")
    }
  }

  def generateType(kindAST: DPIA.Kind.AST): scala.meta.Type = {
    import scala.meta._
    import meta.parser.DPIA.Kind.AST
    kindAST match {
      case AST.RiseKind(riseKind) =>
        import meta.parser.rise.Kind.AST
        riseKind match {
          case AST.Data => Type.Name("DataType")
          case AST.Address => Type.Name("AddressSpace")
          case AST.Nat2Nat => Type.Name("NatToNat")
          case AST.Nat2Data => Type.Name("NatToData")
          case AST.Nat => Type.Name("Nat")
          case AST.Fragment => Type.Name("FragmentKind")
          case AST.MatrixLayout => Type.Name("MatrixLayout")
        }
      case AST.Access => Type.Name("AccessType")
      case AST.VariadicKind(_, kind) => t"Seq[${generateType(kind)}]"
    }
  }

  def generateKindType(kindAST: DPIA.Kind.AST): scala.meta.Type = {
    import scala.meta._
    import meta.parser.DPIA.Kind.AST
    kindAST match {
      case AST.RiseKind(riseKind) =>
        import meta.parser.rise.Kind.AST
        riseKind match {
          case AST.Data => Type.Name("DataKind")
          case AST.Address => Type.Name("AddressSpaceKind")
          case AST.Nat2Nat => Type.Name("NatToNatKind")
          case AST.Nat2Data => Type.Name("NatToDataKind")
          case AST.Nat => Type.Name("NatKind")
          case AST.Fragment => throw new Exception("Can not generate Kind for Fragment")
          case AST.MatrixLayout => throw new Exception("Can not generate Kind for Matrix Layout")
        }
      case AST.Access => Type.Name("AccessKind")
      case AST.VariadicKind(_, _) => throw new Exception("Can not generate Kind for Variadic Kind")
    }
  }

  def generateTerm(typeAST: DPIA.Type.AST): scala.meta.Term = {
    import scala.meta._
    import meta.parser.DPIA.Type.AST
    typeAST match {
      case AST.ExpType(dataType, access) =>
        q"expT(${RisePrimitives.generateDataType(dataType)}, ${generateTerm(access)})"
      case AST.AccType(dataType) =>
        q"accT(${RisePrimitives.generateDataType(dataType)})"
      case AST.CommType =>
        q"comm"
      case AST.PairType(lhs, rhs) =>
        q"PhrasePairType(${generateTerm(lhs)}, ${generateTerm(rhs)})"
      case AST.FunType(inT, outT) =>
        q"FunType(${generateTerm(inT)}, ${generateTerm(outT)})"
      case AST.DepFunType(id, kind, t) =>
        q"DepFunType[${generateKindType(kind)}, PhraseType](${Term.Name(id.name)}, ${generateTerm(t)})"
      case AST.Identifier(name) => Term.Name(name)
      case AST.VariadicType(_, _) => throw new Exception("Can not generate Term for Variadic Type")
    }
  }

  def generateTerm(accessAST: DPIA.Type.Access.AST): scala.meta.Term = {
    import scala.meta._
    import meta.parser.DPIA.Type.Access.AST
    accessAST match {
      case AST.Identifier(name) => Term.Name(name)
      case AST.Read => Term.Name("read")
      case AST.Write =>Term.Name("write")
    }
  }

  def generateVisitAndRebuild(name: scala.meta.Type.Name,
                              paramLists: List[List[scala.meta.Term.Param]]): scala.meta.Defn.Def = {
    import scala.meta._

    object TypeIs {
      def unapply(ty: Type): Option[String] = ty match {
        case Type.Name(name) => Some(name)
        case Type.Select(_, Type.Name(name)) => Some(name)
        case _ => None
      }
    }

    def injectVisitCall(param: Term.Param): Term = {
      param.decltpe match {
        case Some(ty) => ty match {
          case TypeIs("Nat") | TypeIs("NatIdentifier") =>
            q"v.nat(${Term.Name(param.name.value)})"
          case TypeIs("DataType") | TypeIs("ScalarType") | TypeIs("BasicType") =>
            q"v.data(${Term.Name(param.name.value)})"
          case TypeIs("NatToNat") =>
            q"v.natToNat(${Term.Name(param.name.value)})"
          case TypeIs("NatToData") =>
            q"v.natToData(${Term.Name(param.name.value)})"
          case TypeIs("AccessType") =>
            q"v.access(${Term.Name(param.name.value)})"
          case TypeIs("AddressSpace") =>
            q"v.addressSpace(${Term.Name(param.name.value)})"
          case TypeIs("LocalSize") | TypeIs("GlobalSize") =>
            q"${Term.Name(param.name.value)}.visitAndRebuild(v)"
          case t"Phrase[$_]" => q"VisitAndRebuild(${Term.Name(param.name.value)}, v)"
          case t"Vector[Phrase[$_]]" =>  q"${Term.Name(param.name.value)}.map(VisitAndRebuild(_, v))"
          case t"Seq[Phrase[$_]]" => q"${Term.Name(param.name.value)}.map(VisitAndRebuild(_, v))"

          case t"Map[Identifier[_ <: PhraseType], $_]" =>
            q"""${Term.Name(param.name.value)}.map{ case (key, value) =>
                  VisitAndRebuild(key, v).asInstanceOf[Identifier[_ <: PhraseType]] -> value
                }"""

          case Type.Apply(Type.Name("Vector"), List(TypeIs("DataType"))) // Vector[DataType]
            |  Type.Apply(Type.Name("Seq"), List(TypeIs("DataType"))) => // Seq[DataType]
            q"${Term.Name(param.name.value)}.map(v.data)"
          case _ =>
            Term.Name(param.name.value)
        }
        case None => throw new Exception(s"Expected type declaration")
      }
    }

    q"""override def visitAndRebuild(v: VisitAndRebuild.Visitor): $name =
       new $name(...${paramLists.map(_.map(injectVisitCall))})
     """
  }

  def generateUnwrap(paramList: List[scala.meta.Term.Param]): scala.meta.Defn.Def = {
    import scala.meta._
    val (types, names) = paramList.map({
      case Term.Param(_, name, Some(typ), _) => (typ, Term.Name(name.value))
    }).unzip
    q"""
      def unwrap: (..$types) = (..$names)
     """
  }
}
