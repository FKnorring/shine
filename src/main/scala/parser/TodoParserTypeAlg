Todo: This should be implemented in Parser and not in Lexer

private def lexType(column:Int, row:Int,  arr:Array[String] = fileReader.sourceLines):(Either[Token,PreAndErrorToken],Int) = {
//    println("Now in lexType: arr("+column+","+row+") = "+ arr(column)(row))
  var r = row
  if(arr(column)(r)=='('){ //TupleType
    r=r+1
    //ignore whitespaces
    skipWhitespaceWhitoutNewLine(column, r) match {
      case (c, row) => {
        r = row
      }
    }
    val type1Either = lexType(column,r)
//      println("type1Either: "+ type1Either.toString())
    r=type1Either._2
    val type1:ConcreteType = type1Either._1 match {
      case Left(ScalarType(concreteType, span)) => concreteType
      case Left(token) => return (Right(NotExpectedToken("Type", token.toString, token.s, fileReader)),r)
      case Right(e) => return (Right(e),r)
    }
    //ignore whitespaces
    skipWhitespaceWhitoutNewLine(column, r) match {
      case (c, row) => {
        r = row
      }
    }
//      println("type1: "+ type1.toString())
    if(!(arr(column)(r)==',')){
      val loc = Location(column,r)
      val span = new Span(fileReader,loc)
      return (Right(NotExpectedToken(",", arr(column)(r)+"",span, fileReader)), r)
    }
    r=r+1
    //ignore whitespaces
    skipWhitespaceWhitoutNewLine(column, r) match {
      case (c, row) => {
        r = row
      }
    }
    val type2Either = lexType(column,r)
//      println("type2Either: "+ type2Either.toString())
    r=type2Either._2
    val type2:ConcreteType = type2Either._1 match {
      case Left(ScalarType(concreteType, span)) => concreteType
      case Left(token) => return (Right(NotExpectedToken("Type", token.toString, token.s, fileReader)),r)
      case Right(e) => return (Right(e),r)
    }
//      println("type2: "+ type2.toString())
    //ignore whitespaces
    skipWhitespaceWhitoutNewLine(column, r) match {
      case (c, row) => {
        r = row
      }
    }
    if(!(arr(column)(r)==')')){
      val loc = Location(column,r)
      val span = new Span(fileReader,loc)
      return (Right(NotExpectedToken(")", arr(column)(r)+"",span, fileReader)), r)
    }
    r=r+1
    val locBegin = Location(column, row)
    val locEnd = Location(column, r)
    val tupleType = TupleType(type1, type2)
    println("TupleType: "+ tupleType)
    (Left(ScalarType(tupleType, Span(fileReader, locBegin, locEnd))),r)
  }else if(arr(column).length>r+4 && arr(column).substring(r, r+4)=="Idx["){
    r=r+4
    //ignore whitespaces
    skipWhitespaceWhitoutNewLine(column, r) match {
      case (c, row) => {
        r = row
      }
    }
    val (nat,r1) =  lexNatNumber(column,r)
    r=r1-1
    //ignore whitespaces
    skipWhitespaceWhitoutNewLine(column, r) match {
      case (c, row) => {
        r = row
      }
    }
    if(!(arr(column)(r)==']')){
      val loc = Location(column,r)
      val span = new Span(fileReader,loc)
      return (Right(NotExpectedToken("]", arr(column)(r)+"",span, fileReader)), r)
    }
    r=r+1
    val locBegin = Location(column, row)
    val locEnd = Location(column, r)
    val indexType = IndexType(nat)
    println("indexType: "+ indexType)
    (Left(ScalarType(indexType, Span(fileReader, locBegin, locEnd))),r)
  }else if(arr(column)(r).isLetterOrDigit){//ArrayType
    val (nat,r1) =  if(arr(column)(r).isDigit) {
      println("Ja: "+ arr(column)(r))
      lexNatNumber(column,r)
    }else{
      println("Nein: "+arr(column)(r))
      lexIdentifier(column,row)
    }
    r=r1
    if(arr(column).length<=r|| !(arr(column)(r)=='.')){
      if(!(arr(column).length<=r) && arr(column)(r)==':'){
        println("We see an ':'")
        val loc:Location = Location(column, r)
        val span =  new Span(fileReader,loc)
        return (Right(NotExpectedToken('.'+"", ':'+"", span, fileReader)), r)
      }
      if(!(arr(column).length<=r)){
        println("We don't see an '.', but an "+ arr(column)(r))
      }
      return lexScalarType(column,row)
    }
    r=r+1
    val typeArrayEither = lexType(column,r)
    println("typeArrayEither: "+ typeArrayEither.toString())
    r=typeArrayEither._2
    val typeArray:ConcreteType = typeArrayEither._1 match {
      case Left(ScalarType(concreteType, span)) => concreteType
      case Left(token) => return (Right(NotExpectedToken("Type", token.toString, token.s, fileReader)),r)
      case Right(e) => return (Right(e),r)
    }
    println("typeArray: "+ typeArray.toString())
    val locBegin = Location(column, row)
    val locEnd = Location(column, r)
    val arrType = nat match {
      case NatNumber(n) => ArrayType(NatNumber(n), typeArray)
        //Todo: How should I implement an TypeIdentifier in ArrayType and how should I work with it????
      case Left(TypeIdentifier(name,_)) => ArrayType(NatIdent(name), typeArray)
      case Left(Identifier(name,span))=> {
        println("We see an Identifier and not an TypeIdentifier: "+ name)
        return (Right(TypeIdentifierExpectedNotIdentifier(name, span, fileReader)),r)
      }
      case t => {
        println("This is completely wrong: "+ t)
        return (Right(NotExpectedToken("5 or 'N'", t.toString, Span(fileReader,Location(column,row), Location(column, r)), fileReader)), r)
      }
    }
    println("arrType: "+ arrType)
    (Left(ScalarType(arrType, Span(fileReader, locBegin, locEnd))),r)
  }else{
    val loc = Location(column, r)
    (Right(NotExpectedToken("We expect a ScalarType or an CombinedType", ""+arr(column)(r), new Span(fileReader, loc), fileReader)), r)
  }
}