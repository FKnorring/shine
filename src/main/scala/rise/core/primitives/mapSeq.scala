// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! //
// This file is automatically generated and should not be changed manually //
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! //
package rise.core.primitives
import rise.core.DSL._
import rise.core.DSL.Type._
import rise.core._
import rise.core.types.{read, _}
import rise.core.types.DataType._
import arithexpr.arithmetic._

object mapSeq extends Builder {
  private final case class Primitive()(override val t: ExprType = TypePlaceholder) extends rise.core.Primitive {
    override val name: String = "mapSeq"

    override def setType(ty: ExprType): Primitive = Primitive()(ty)

    override def primEq(obj: rise.core.Primitive): Boolean = obj.getClass == getClass

    override def typeScheme: ExprType = impl { (n: Nat) => impl { (s: DataType) => impl { (t: DataType) => (s ->: t) ->: ArrayType(n, s) ->: ArrayType(n, t) } } }
    override def toDPIA: shine.DPIA.Phrases.Phrase[_ <: shine.DPIA.Types.PhraseType] = {
      import shine.DPIA._
      import shine.DPIA.Types._
      import shine.DPIA.fromRise.fun
      import shine.DPIA.primitives.functional.MapSeq
      t match {
        case ((s: DataType) ->: (t: DataType)) ->: ArrayType(n, s2) ->: ArrayType(n2, t2) if s == s2 && t == t2 && n == n2 =>
          fun[ExpType ->: ExpType](expT(s, read) ->: expT(t, write), f =>
            fun[ExpType](expT(ArrayType(n, s), read), e =>
              MapSeq(unroll = false)(n, s, t, f, e)))
        case _ => shine.DPIA.error()
      }
    }

  }
  override def toString: String = "mapSeq"
  override def primitive: rise.core.Primitive = Primitive()()
  override def apply: ToBeTyped[rise.core.Primitive] = toBeTyped(Primitive()())
  override def unapply(arg: Expr): Boolean = arg match {
    case _: Primitive => true
    case _ => false
  }
}
