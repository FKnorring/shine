identity:=x->x

calcAcc::4xF32->4xF32->F32->F32->4xF32->4xF32
foreign calcAcc(p1,p2,deltaT, espSqr, acc){
   float4 r;
   r.xyz = p2.xyz - p1.xyz;
   float distSqr = r.x*r.x + r.y*r.y + r.z*r.z;
   float invDist = 1.0f / sqrt(distSqr + espSqr);
   float invDistCube = invDist * invDist * invDist;
   float s = invDistCube * p2.w;
   float4 res;
   res.xyz = acc.xyz + s * r.xyz;
   return res;
}
update::4xF32->4xF32->F32->4xF32->(4xF32,4xF32)
foreign update(pos, vel, deltaT, acceleration){
  float4 newPos;
  newPos.xyz = pos.xyz + vel.xyz * deltaT + 0.5f * acceleration.xyz * deltaT * deltaT;
  newPos.w = pos.w;
  float4 newVel;
  newVel.xyz = vel.xyz + acceleration.xyz * deltaT;
  newVel.w = vel.w;
  return (struct Record_float4_float4){ newPos, newVel };
}

tileX:= 256N
tileY:= 1N

nbody::N:Nat=>N.4xF32->N.4xF32->F32->F32->N.(4xF32,4xF32)
nbody=N:Nat=>pos->vel->espSqr->deltaT->
join . join . (mapWorkGroup 1 
join . (mapWorkGroup 0 p1Chunk -> 
  newP1Chunk-> 
  (mapLocal 1 bla->
    (mapLocal 0 p1-> 
	update (fst (fst p1)) (snd (fst p1)) deltaT (snd p1))
    (zip newP1Chunk bla)). 
    (oclReduceSeq Local (
	accA->p2->
  	  let (toLocal (mapLocal 1 (mapLocal 0 identity) p2))(
    p2Local -> (mapLocal 1 accDim-> 
	(mapLocal 0 p1 -> (oclReduceSeq Private accB->p2-> 
	calcAcc (fst (fst p1)) p2 deltaT espSqr accB) 
    (snd p1) (fst accDim)) 
   (zip newP1Chunk (snd accDim))) 
  (zip p2Local accA))
   )(mapLocal 1 (mapLocal 0 identity) (generate plh1-> generate plh2->vectorFromScalar 0F32)))
          . (split tileY). ( split tileX ) pos
        (zip(toLocal(mapLocal 0 identity (fst (unzip p1Chunk))))(snd (unzip p1Chunk)))
        ). (split tileX)
      ). (split N) ( zip pos vel)