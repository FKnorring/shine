--titleX::Nat --I have to add that I can create Arrays etc with FunctionNames with Type Nat
--titleX=256
--titleY::Nat
--titleY=1

nbody::N:Nat=>N.4xF32->N.4xF32->F32->F32->N.(4xF32,4xF32) --4xF32 for vec(4,f32)
nbody=\N:Nat=>\pos->\vel->\espSqr->\deltaT->
 join (
 join (
   mapWorkGroup 1
   (
      join (
      mapWorkGroup 0 (
        \p1Chunk:(256.(4xF32, 4xF32)->1.256.(4xF32, 4xF32)) ->
        \newP1Chunk:256.(4xF32, 4xF32)->
        mapLocal 1 (
          \bla:256.4xF32->
          mapLocal 0 (
            \p1A:((4xF32, 4xF32), 4xF32)->
            update (fst (fst p1A)) (fst (snd p1A)) deltaT (snd p1A)
          )
          (zip newP1Chunk bla)
        )
        (
          oclReduceSeq Local --I have to add AddrSpace.Local in matchPrimitiveAndIdentifier, because there it is easy
          (
          \accA:1.256.4xF32->\p2A:1.256.4xF32->
          let (toLocal (mapLocal 1 (mapLocal 0 (\x1->x1))) p2A) --toLocal adden --"id" is a primitive in RISE and cannot be used as name
          (
            \p2Local -> mapLocal 1 (
              \accDim-> mapLocal 0 (
                \p1B -> oclReduceSeq Private (
                  \accB:4xF32->\p2B:4xF32->
                  calcAcc (fst (fst p1B)) p2B deltaT espSqr accB
                ) (snd p1B) (fst accDim2)
              ) (zip newP1Chunk (snd (snd accDim)))
            ) (zip p2Local accA)
          ) 
          )
          (mapLocal 1 (mapLocal 0 (\x2->x2)) (generate (vectorFromScalar 0)))
        )
        (split 1N ( split 256N pos))
      ) (split 256N)
      )
   )
    (split N ( zip pos vel))
    )
  )

