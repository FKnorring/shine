nbody::N:Nat=>N.4xF32->N.4xF32->F32->F32->N.(4xF32,4xF32) --4xF32 for vec(4,f32)
nbody=\N:Nat=>\pos->\vel->\espSqr->\deltaT->
 join (
 join (
   mapWorkGroup 1
   (
      join (
      mapWorkGroup 0 (
        \p1Chunk:(256.(4xF32, 4xF32)->1.256.(4xF32, 4xF32)) ->
        \newP1Chunk:256.(4xF32, 4xF32)->
        mapLocal 1 (
          \bla:256.4xF32->
          mapLocal 0 (
            \p1A:((4xF32, 4xF32), 4xF32)->
            update (fst (fst p1A)) (snd (fst p1A)) deltaT (snd p1A)
          )
          (zip newP1Chunk bla)
        )
        (
          oclReduceSeq Local --I have to add AddrSpace.Local in matchPrimitiveAndIdentifier, because there it is easy
          (
          \accA:1.256.4xF32->\p2A:1.256.4xF32->
          (let (toLocal (mapLocal 1 (mapLocal 0 (\x1->x1)) p2A)))
          (
            \p2Local -> mapLocal 1 (
              \accDim-> mapLocal 0 (
                \p1B -> oclReduceSeq Private (
                  \accB:4xF32->\p2B:4xF32->
                  calcAcc (fst (fst p1B)) p2B deltaT espSqr accB
                ) (snd p1B) (fst accDim)
              ) (zip newP1Chunk (snd accDim))
            ) (zip p2Local accA)
          )
          )
          (mapLocal 1 (mapLocal 0 (\x2->x2)) (generate (\plh1-> generate (\plh2->vectorFromScalar 0F32))))
          (split 1N ( split 256N pos))
        )
      ) (split 256N)
      )
   )
    (split N ( zip pos vel))
    )
  )