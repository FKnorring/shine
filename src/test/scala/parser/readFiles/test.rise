--a simple 'fgn' to declare foreign Functions
update::4xF32->..->(4xF32,4xF32) --Todo:this is the way for foreign function
foreign update(p1,p2,deltaT, espSqr, acc){
  float4 r;
   r.xyz = p2.xyz - p1.xyz;
   float distSqr = r.x*r.x + r.y*r.y + r.z*r.z;
   float invDist = 1.0f / sqrt(distSqr + espSqr);
   float invDistCube = invDist * invDist * invDist;
   float s = invDistCube * p2.w;
   float4 res;
   res.xyz = acc.xyz + s * r.xyz;
   return res;
}--https://www.haskell.org/haddock/doc/html/index.html

--Todo:under here is a not implemented method for multiline comments, which exists in Hadkell
{-Todo:this is for future work a feature
this seems to be a comment in Haskell
but not in RISE ' asdf'
@asdfaskf√∂ja kj
asdf <www.google.com> asdfadsf

=Heading

===Subheading

-}
--this could be a block of foreign functions,
-- which means that we have minimal problems with these foreign code
-- maybe with this we are able to import different types of foreign code into our rise-Code
-- only problem it is very similar to multiline comments
-- Todo: ask Bastian if we want to have struct in foreign functions too, because I don't know if it is
-- Todo: yet possible, but with this method it is much easier and better to read modifiable, because it is
-- Todo: just a huge block of the functions and structs in C
{-#
update(p1,p2,deltaT, espSqr, acc){
  float4 r;
   r.xyz = p2.xyz - p1.xyz;
   float distSqr = r.x*r.x + r.y*r.y + r.z*r.z;
   float invDist = 1.0f / sqrt(distSqr + espSqr);
   float invDistCube = invDist * invDist * invDist;
   float s = invDistCube * p2.w;
   float4 res;
   res.xyz = acc.xyz + s * r.xyz;
   return res;
}
calcAcc(){

}
#-}
{-|
* Beginning of list
This belongs to the list above!

    > nested
    > bird
    > tracks

    * Next list
    More of the indented list.

        * Deeper

            @
            even code blocks work
            @

            * Deeper

                    1. Even deeper!
                    2. No newline separation even in indented lists.
-}

-- | This is a definition list:
--
--   [@foo@] The description of @foo@.
--
--   [@bar@] The description of @bar@.

-- | This documentation includes two blocks of code:
--
-- @
--     f x = x + x
-- @
--
-- >  g x = x * 42

nbody::N:Nat=>N.4xF32->N.4xF32->F32->F32->N.(4xF32,4xF32) --4xF32 for vec(4,f32)
nbody=\N:Nat=>\pos->\vel->\espSqr->\deltaT->
 join (
 join (
   mapWorkGroup 1
   (
      join (
      mapWorkGroup 0 (
        \p1Chunk ->
        (
        \newP1Chunk->
        mapLocal 1 (
          \bla->
          mapLocal 0 (
            \p1A->
            update (fst (fst p1A)) (snd (fst p1A)) deltaT (snd p1A)
          )
          (zip newP1Chunk bla)
        )
        (
          oclReduceSeq Local --I have to add AddrSpace.Local in matchPrimitiveAndIdentifier, because there it is easy
          (
          \accA->\p2A->
          let (toLocal (mapLocal 1 (mapLocal 0 (\x1->x1)) p2A))
           (
            \p2Local -> mapLocal 1 (
              \accDim-> mapLocal 0 (
                \p1B -> oclReduceSeq Private (
                  \accB->\p2B->
                  calcAcc (fst (fst p1B)) p2B deltaT espSqr accB
                ) (snd p1B) (fst accDim)
              ) (zip newP1Chunk (snd accDim))
            ) (zip p2Local accA)
          )
          )
          (mapLocal 1 (mapLocal 0 (\x2->x2)) (generate (\plh1-> generate (\plh2->vectorFromScalar 0F32))))--N.N.4xF32
          (split 1N ( split 256N pos))--(N/256).1.256.4xF32
        )(zip(toLocal(mapLocal 0 (\x3->x3) (fst (unzip p1Chunk))))(snd (unzip p1Chunk)))--zip(toLocal(mapLocal(id)(unzip(p1Chunk)._1)))(unzip(p1Chunk)._2)
        )
      ) (split 256N (split N ( zip pos vel)))
      )
   )
    )
  )